confint(lmod)
#### Goodness of fit
pchisq(deviance(lmod), df.residual(lmod), lower=FALSE)
### Predict
n_pred <- 10000
exp(as.numeric(lmod$coefficients[1]) + as.numeric(lmod$coefficients[2])*n_pred^(-1/4))/
(1 + exp(as.numeric(lmod$coefficients[1]) + as.numeric(lmod$coefficients[2])*n_pred^(-1/4)))
## Plots
### Observed and Expected stable matchings
dfPlot <- data.frame(stable = c(observed, expected),
type = rep(c("Observed", "Expected"), each = length(observed)),
n = rep(df$n, times = 2))
ggplot(dfPlot, aes(x=c(1:11, 1:11), y=stable, color = type, shape= type)) + geom_point(size = 2) + theme_light() +
expand_limits(y=0) +
ylab("Frequency of stable") + xlab(expression('n'[room])) + theme(legend.title = element_blank(), legend.position=c(0.8, 0.9))
scale_x_continuous(breaks = c(0, 2500, 5000)) # , 7500, 10000, 12500, 15000, 17500, 20000
ggsave("freq_observed_vs_expected.png")
### Time
dfPlot <- data.frame(time = c(df$t_roomST/df$stable, df$t_roomUN/df$unstable),
type = rep(c("Stable", "Unstable"), each = length(observed)),
samples = rep(df$samples_real, times = 2),
n = rep(df$n, times = 2))
ggplot(dfPlot, aes(x = n, y = time, color = type)) + geom_point(size = 1) + theme_light() +
expand_limits(y = 0, x = 0) + theme(legend.title = element_blank(), legend.position=c(0.25, 0.8)) +
ylab(expression(paste(bar('t'), plain( (s) )))) + xlab(expression('n')) +
stat_smooth(aes(fill = type), method = 'lm', formula = y ~ I(x^2), se = F, lwd = 0.5) +
scale_colour_brewer(palette = "Set1")
ggsave("time_irving.png", width = 7)
##### linear model
sink("lm.txt", append = F, type = "output")
summary(lmfit <- lm(time ~ I(n^2)*type, data = dfPlot))
closeAllConnections()
### Diferences
dfPlot <- data.frame(stable = observed - expected, type = factor(df$n),
n = 1:length(df$n))
ggplot(dfPlot, aes(x=type, y=stable, color = type)) + geom_point(size = 1) + theme_light() +
expand_limits(y=0) +
ylab("Observed - Expected") + xlab(expression('n'[room])) + theme(legend.title = element_blank())
ggsave("DifferencesObserved.png")
## Pn vs Pn_obs
pframe <- with(df, expand.grid(n=seq(0, max(df$n),length=100)))
pframe$Pn_estimat <- predict(lmod, newdata=pframe, type="response")
ggplot(df, aes(x=n, y=Pn_estimat)) + geom_point(shape = 18) + theme_light() +
expand_limits(y = c(0, 1), x = 0) +
ylab(expression('P'[n])) + xlab(expression('n')) +
geom_function(fun = Pn, aes(colour = "red")) +
geom_line(data=pframe, aes(colour = 'blue')) +
scale_colour_brewer(labels = c("Experimental", "Mertens"), palette = "Set1") +
theme(legend.title = element_blank(), legend.position=c(0.75, 0.8))
ggsave("Pn_vs_observed.png", width = 7)
# Script que analitza els resultats
library(ggplot2)
## Probabilitat de Mertens
Pn <- function(n) return(exp(1)*(1/sqrt(pi))*(4/n)^(1/4))
## Llegim les dades
df <- read.csv("experiment_size_11.csv", header = T)
## Analisis de les dades
df$samples_real <- df$stable + df$unstable
### Estimacio de Pn
Pn_estimat <- (df$stable/df$samples_real)
df$Pn_estimat <- Pn_estimat
### Desviacio per Pn
round(Pn_desviacio <- sqrt(Pn_estimat*(1- Pn_estimat)/df$sample), 3)
### Interval de confianca per Pn al 95%
(ICp <- round(c(Pn_estimat + 1.96*Pn_desviacio), 3))
(ICn <- round(c(Pn_estimat - 1.96*Pn_desviacio), 3))
###
err = abs(abs(Pn_estimat - Pn(df$n)))
### times
(t_st <- round(df$t_roomST/df$stable, 3))
(t_un <- round(df$t_roomUN/df$unstable, 3))
(t_ge <- round(df$t_gen/df$samples_real, 3))
(t_to <- round((df$t_gen + df$t_roomST + df$t_roomUN)/3600, 3))
### Chi square
expected <- df$samples_real * Pn(df$n)
observed <- df$stable
chi_val <- sum( (observed - expected )^2/expected)
pvalue <- (1 - pchisq(chi_val, df = length(observed) - 1))
print(paste0("Chi-square value: ", round(chi_val, 3), ", p-value: ", round(pvalue, 3)))
### Generalized linear Model
lmod <- glm(cbind(stable, samples_real-stable) ~ I(n^(-1/4)),
family=binomial, data = df)
#### Summary fit
sink("lmod.txt", append = F, type = "output")
summary(lmod)
closeAllConnections()
#### IC pel fit
confint(lmod)
#### Goodness of fit
pchisq(deviance(lmod), df.residual(lmod), lower=FALSE)
### Predict
n_pred <- 10000
exp(as.numeric(lmod$coefficients[1]) + as.numeric(lmod$coefficients[2])*n_pred^(-1/4))/
(1 + exp(as.numeric(lmod$coefficients[1]) + as.numeric(lmod$coefficients[2])*n_pred^(-1/4)))
## Plots
### Time
dfPlot <- data.frame(time = c(df$t_roomST/df$stable, df$t_roomUN/df$unstable),
type = rep(c("Stable", "Unstable"), each = length(observed)),
samples = rep(df$samples_real, times = 2),
n = rep(df$n, times = 2))
ggplot(dfPlot, aes(x = n, y = time, color = type)) + geom_point(size = 1) + theme_light() +
expand_limits(y = 0, x = 0) + theme(legend.title = element_blank(), legend.position=c(0.25, 0.8)) +
ylab(expression(paste(bar('t'), plain( (s) )))) + xlab(expression('n')) +
stat_smooth(aes(fill = type), method = 'lm', formula = y ~ I(x^2), se = F, lwd = 0.5) +
scale_colour_brewer(palette = "Set1")
ggsave("time_irving.png", width = 7)
##### linear model
sink("lm.txt", append = F, type = "output")
summary(lmfit <- lm(time ~ I(n^2)*type, data = dfPlot))
closeAllConnections()
### Pn vs Pn_obs
pframe <- with(df, expand.grid(n=seq(min(df$n), max(df$n),length=100)))
pframe$Pn_estimat <- predict(lmod, newdata=pframe, type="response")
ggplot(df, aes(x=n, y=Pn_estimat)) + geom_point(shape = 18) + theme_light() +
expand_limits(y = c(0, 0.75), x = 0) +
ylab(expression('P'[n])) + xlab(expression('n')) +
geom_function(fun = Pn, aes(colour = "red")) +
geom_line(data=pframe, aes(colour = 'blue')) +
scale_colour_brewer(labels = c("Experimental", "Mertens"), palette = "Set1") +
theme(legend.title = element_blank(), legend.position=c(0.75, 0.8))
ggsave("Pn_vs_observed.png", width = 7)
7.9 %% 4
mix <- c(9, 3, 0.7)
mix[1]*(1-mix[3]) + mix[2]*mix[3]
7.9 %% 4
rgba[4]*rgba +  (1 - rgba[4])*buff
rgba = c(1.0, 0.5, 0.0, 0.4)
buff = c(0.5, 0.5, 1.0, 1.0)
rgba[4]*rgba + (1 - rgba[4])*buff
# textura de 1024x1024 1MB, si fem mipmapping
# 1024x1024, 512**512, ...
MB = 0
for (i in 0:10) {
MB = MB + 2**i
}
MB
2**10
# textura de 1024x1024 1MB, si fem mipmapping
# 1024x1024, 512**512, ...
MB = 0
for (i in 0:10) {
MB = MB + (2**i)*(2**i)
}
MB
# textura de 1024x1024 1MB, si fem mipmapping
# 1024x1024, 512**512, ...
MB = 0
for (i in 0:10) {
MB = MB + (2**i)*(2**i)
}
MB
MB/(2**20)
rgba = c(1.0, 0.5, 0.0, 0.8)
buff = c(1.0, 0.5, 1.0, 1.0)
rgba[4]*rgba + (1 - rgba[4])*buff
log2(256)
1 + log2(256)
# tenint en compte LOD 0
1 + log2(512)
rgba = c(1.0, 0.5, 0.0, 0.8)
buff = c(1.0, 1.0, 0.0, 0.0)
rgba[4]*rgba + (1 - rgba[4])*buff
rgba = c(1.0, 0.5, 0.0, 0.9)
buff = c(1.0, 1.0, 0.0, 0.0)
rgba[4]*rgba + (1 - rgba[4])*buff
rgba = c(1.0, 0.5, 0.0, 0.5)
buff = c(1.0, 1.0, 0.0, 0.0)
rgba[4]*rgba + (1 - rgba[4])*buff
rgba = c(1.0, 0.5, 0.0, 0.4)
buff = c(1.0, 1.0, 0.0, 0.0)
rgba[4]*rgba + (1 - rgba[4])*buff
rgba = c(1.0, 0.5, 0.0, 0.2)
buff = c(1.0, 1.0, 0.5, 0.0)
rgba[4]*rgba + (1 - rgba[4])*buff
(1 - rgba[4])*rgba + rgba[4]*buff
rgba = c(1.0, 0.5, 0.0, 0.2)
buff = c(0.3, 0.1, 0.3, 0.7)
rgba[4]*rgba + (1 - rgba[4])*buff # SRC, ONE_MINUS
# (1 - rgba[4])*rgba + rgba[4]*buff # ONE_MINUS, SRC
rgba = c(1.0, 0.5, 0.0, 0.2)
buff = c(0.3, 0.1, 0.3, 0.7)
rgba[4]*rgba + (1 - rgba[4])*buff # SRC, ONE_MINUS
(1 - rgba[4])*rgba + rgba[4]*buff # ONE_MINUS, SRC
alpha_beta_gamma <- c(0.5, 0.3, 0.2)
area_triangle <-7
print(paste("Area ABX", area_triangle*alpha_beta_gamma[3]))
print(paste("Area ACX", area_triangle*alpha_beta_gamma[2]))
print(paste("Area BCX", area_triangle*alpha_beta_gamma[1]))
rgba = c(0.7, 0.9, 0.7, 0.6)
buff = c(0.2, 0.3, 0.6, 0.1)
rgba[4]*rgba + (1 - rgba[4])*buff # SRC, ONE_MINUS
# (1 - rgba[4])*rgba + rgba[4]*buff # ONE_MINUS, SRC
# Quants rays numero piexle
# Quants rays numero piexl
pixels <- 1024*1080
numero_llums <- 4
shadow_rays <- pixels*numero_llums
shadow_rays
6.1 %% 3
sum(textura_s * alpha_beta_gamma)
textura_s <- c(0.1, 0.3, 0.1)
alpha_beta_gamma <- c(0.4, 0.1, 0.5)
sum(textura_s * alpha_beta_gamma)
textura_s <- c(0.6, 0.3, 0.5)
alpha_beta_gamma <- c(0.4, 0.2, 0.4)
sum(textura_s * alpha_beta_gamma)
rgba = c(0.9, 0.1, 0.5, 0.1)
buff = c(0.3, 0.8, 0.6, 0.2)
rgba[4]*rgba + (1 - rgba[4])*buff # SRC, ONE_MINUS
# (1 - rgba[4])*rgba + rgba[4]*buff # ONE_MINUS, SRC
# Quants rays numero piexl
pixels <- 1920*480
numero_llums <- 2
shadow_rays <- pixels*numero_llums
shadow_rays
alpha_beta_gamma <- c(0.3, 0.2, 0.5)
area_triangle <-4
print(paste("Area ABX", area_triangle*alpha_beta_gamma[3]))
print(paste("Area ACX", area_triangle*alpha_beta_gamma[2]))
print(paste("Area BCX", area_triangle*alpha_beta_gamma[1]))
7.4 %% 3
homo <- c(8, 2.00, 6, 2)
homo[1:3]/homo[4]
homo <- c(8, 2.00, 16, 2)
homo[1:3]/homo[4]
log2(2)
N = c(1, 0, 0)
L = c(1, 0, 0)
2*(N%*%L)*N - L
(N%*%L)
(N%*%L)*N
min = c(0,0,0)
max = c(1,5,0)
2*4/(max[1])
2*3/(max[2])
color1 = c(1,1,0)
color2 = c(0,1,1)
mean(color1 + color2)
color1 = c(1,1,0)
color2 = c(0,1,1)
(color1 + color2)/2
color1 = c(1,0,1)
color2 = c(0,1,1)
(color1 + color2)/2
# theta = 2*pi*s
# psi = (t - 0.5)*pi
theta = 0.6
psi = 1.1
x = cos(psi)*sin(theta)
y = sin(psi)
z = cos(psi)*cos(theta)
round(c(x, y, z), 2)
alpha_beta_gamma <- c(0.5, 0.3, 0.2)
area_triangle <-7
print(paste("Area ABX", area_triangle*alpha_beta_gamma[3]))
print(paste("Area ACX", area_triangle*alpha_beta_gamma[2]))
print(paste("Area BCX", area_triangle*alpha_beta_gamma[1]))
rgba = c(0.7, 0.9, 0.7, 0.6)
buff = c(0.2, 0.3, 0.6, 0.1)
rgba[4]*rgba + (1 - rgba[4])*buff # SRC_ALPHA, ONE_MINUS_SRC_ALPHA
# Quants rays numero piexl
pixels <- 1024*1080
numero_llums <- 4
shadow_rays <- pixels*numero_llums
shadow_rays
(shadow_rays <- pixels*numero_llums)
textura_s <- c(0.1, 0.3, 0.1)
alpha_beta_gamma <- c(0.4, 0.1, 0.5)
sum(textura_s * alpha_beta_gamma)
alpha_beta_gamma <- c(0.3, 0.2, 0.5)
area_triangle <-4
print(paste("Area ABX", area_triangle*alpha_beta_gamma[3]))
print(paste("Area ACX", area_triangle*alpha_beta_gamma[2]))
print(paste("Area BCX", area_triangle*alpha_beta_gamma[1]))
rgba = c(0.7, 0.9, 0.7, 0.6)
buff = c(0.2, 0.3, 0.6, 0.1)
rgba[4]*rgba + (1 - rgba[4])*buff # SRC_ALPHA, ONE_MINUS_SRC_ALPHA
# (1 - rgba[4])*rgba + rgba[4]*buff # ONE_MINUS, SRC
textura_s <- c(0.8, 0.3, 0.9)
alpha_beta_gamma <- c(0.4, 0.3, 0.3)
sum(textura_s * alpha_beta_gamma)
log2(4)
theta = 2.7
psi = 0.8
x = cos(psi)*sin(theta)
y = sin(psi)
z = cos(psi)*cos(theta)
round(c(x, y, z), 2)
color1 = c(1,1,0)
color2 = c(0,1,1)
(color1 + color2)/2
rgba = c(1.0, 0.5, 0.0, 0.4)
buff = c(0.5, 0.5, 1.0, 1.0)
rgba[4]*rgba + (1 - rgba[4])*buff # SRC_ALPHA, ONE_MINUS_SRC_ALPHA
# textura de 1024x1024 1MB, si fem mipmapping
# 1024x1024, 512**512, ...
MB = 0
for (i in 0:10) {
MB = MB + (2**i)*(2**i)
}
MB/(2**20)
MB = 0
for (i in 0:8) {
MB = MB + (2**i)*(2**i)
}
MB
MB/(2**16)
# tenint en compte LOD 0
1 + log2(256)
# tenint en compte LOD 0
1 + log2(512)
pixels <- 1024*1024    # raigos primaris
(pixels <- 1024*1024)    # raigos primaris
2**20
numero_llums <- 4
(shadow_rays <- pixels*numero_llums)
rgba = c(1.0, 0.5, 0.0, 0.2)
buff = c(1.0, 1.0, 0.5, 0.0)
# rgba[4]*rgba + (1 - rgba[4])*buff # SRC_ALPHA, ONE_MINUS_SRC_ALPHA
(1 - rgba[4])*rgba + rgba[4]*buff # ONE_MINUS, SRC
(pixels <- 256*256)    # raigos primaris
numero_llums <- 4
(shadow_rays <- pixels*numero_llums)
(reflectits <- pixels*0.5 * pixels/2)
(reflectits <- pixels*0.5)
(reflectits <- pixels*0.5 + pixels/4)  # 2  nivell de rec
(antialiasing <- 4*pixels)  # 2  nivell de rec
rgba = c(1.0, 0.5, 0.0, 0.2)
buff = c(1.0, 1.0, 0.5, 0.0)
rgba[4]*rgba + (1 - rgba[4])*buff # SRC_ALPHA, ONE_MINUS_SRC_ALPHA
# (1 - rgba[4])*rgba + rgba[4]*buff # ONE_MINUS_SRC_ALPHA, SRC_ALPHA
(rgba[4])*rgba + 1*buff # GL_SRC_ALPHA, ONE
```{r}
rgba = c(1.0, 0.5, 0.0, 0.2)
buff = c(0.3, 0.1, 0.3, 0.7)
rgba[4]*rgba + (1 - rgba[4])*buff # SRC_ALPHA, ONE_MINUS_SRC_ALPHA
(rgba[4])*rgba + 1*buff # GL_SRC_ALPHA, ONE
x = 10
y = 2
z = 0
theta = atan2(x, z)
psi = asin(y)
s = theta/(2*pi)
t = psi/pi + 0.5
theta = 2.7
x = 10
y = 2
z = 0
theta = atan2(x, z)
psi = asin(y)
s = theta/(2*pi)
t = psi/pi + 0.5
theta
psi
asin(y)
y = 2
asin(y)
psi = asin(pi)
psi
asin(pi)
15.09 + 19.68 + 11.28 + 24.68 + 11.6
13.21 + 14.09 + 24.68 + 11.6 + 15.09
sum(c(4.31 + 8.96,  10.72 + 3.37,  14.26 + 10.42,  11.04 + 0.56,  1.97 + 13.12))
sum(c(1.97 + 13.12,
10.72 + 8.96,
7.91 + 3.37,
14.26 + 10.42,
11.04 + 0.56))
li <- c(6.09,5.87,2.11,5.83,5.53,2.95,0.48,7.16,4.04,1.29,7.03,4.61,9.52,2.88,6.3,4.91,5.51,7.45,6.79,7.83,3.7,0.04,6.08,1.62,6.75,8.65,5.88,0.06,7.53,0.5,3.81,7.03,0.12,1.81,4.71,6.04,7.57,6.14,6.06,5.98,8.37,9.1,0,0,0.46,4.92,8.1,6.49,3.46,1.17,7.73,7.24,6.73,5.77,7.76,0.32,9.41,3.73,7.41,2.91,3.95,9.01,9.07,9.04,4.02,9.64,0,4.53,8.75,9.17,6.06,3.52,3.88,4,4.32,6.8,7.18,3.47,5.77,5.63,5.03,6.09,5.31,0,4.66,2.65,3.42,2.5,3.28,3.51,1.24,0,2.95,4.61,8.04,5.21,9.34,1.96,7.85,3.09,5.59,5.56)
length(li)
length(sum(li>5))
li>5
(sum(li>5))
(sum(li>=5))
(sum(li>=5))
(sum(li>=5))/102
x <-  c(1,2,3,4,5)
y <- c(7.97, 10.2, 14.2, 16.0, 21.2)
lm(y ~ x)
summaray(lm(y ~ x))
summary(lm(y ~ x))
A = matrix(0, 5, 5)
for (i in 1:5) {
for (j in 1:5) {
A[i, j] = 1/(i + j)
}
}
print(det(A))
print(1/266716800000)
print(eigen(A))
A = matrix(0, 5, 5)
for (i in 1:5) {
for (j in 1:5) {
A[i, j] = 1/(i + j - 1)
}
}
print(det(A))
print(1/266716800000)
print(eigen(A))
x <-  c(1,2,3,4,5)
y <- c(7.97, 10.2, 14.2, 16.0, 21.2)
summary(lm(y ~ x))
library(e1071)
library(kernlab)
library(jpeg)
library(imager)
library(data.table)
# setwd("D:/UPC/3R/AA2/AA2-projecte/")
path = "data/training_set"
classes <- list.files(path)
dataset <- data.frame()
max.w = 0
max.h = 0
# save(dataset, file = "dades.RData")
load("dades.RData")
getwd()
notes <- c(8.1,5.9,6.1,9.1,5.1,6.7,8.1,6.2,8.2,8.7,6.2,8.6,6,8.1,8.6,6.3,4.2,6.8,7.2,7.1,9,5.5,6.7,8.1,6.7,6.1,7.3,4.5,6.6,5,7.2,4.5,8,5.7,8.3,7.9,8.4,7.5,7.4,7.3,7,6.1,4.7,7.3,4.2,4.1,8.4,7.5,5.5,7.6,6.8,6.8,6,4.5,7.9,6.9)
quantile(notes)
version
version()
versionInfo()
versionInfo()
source("~/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/main.R")
source("~/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/main.R")
source("process_data.R")
source("~/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/main.R")
Cs = c(0.001, 0.01, 0.1, 1, 10, 100, 1000)
kernels = c("vanilladot", "rbfdot", "polydot", "gihdot", "logdot",
"laplacedot", "mix_rbfdot_polydot", "mix_rbfdot_logdot",
"mix_logdot_polydot", "mix_rbfdot_gihdot",
"mix_logdot_gihdot","mix_polydot_gihdot")
df <- data.frame(matrix(0, nrow = length(kernels), ncol = length(Cs)), row.names = kernels ); names(df) <- Cs
library(kernlab)
library(imager)
library(xtable)
library(caret)
library(class)
options(scipen = 999)
# setwd('/home/benja/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/')
source("process_data.R")
# Read Data, only if it doesnt exist
if (!file.exists('data/train.RData')) read_data(train = T)
if (!file.exists('data/test.RData')) read_data(train = F)
# clear workspace
rm(list = ls())
load("data/train.RData")
load("data/test.RData")
# Fits an SVM
lambda <- 0.5; sigma_rbf <- 1; degree <- 2; beta <- 0.25; beta_gih <- 0.25
Cs = c(0.001, 0.01, 0.1, 1, 10, 100, 1000)
kernels = c("vanilladot", "rbfdot", "polydot", "gihdot", "logdot",
"laplacedot", "mix_rbfdot_polydot", "mix_rbfdot_logdot",
"mix_logdot_polydot", "mix_rbfdot_gihdot",
"mix_logdot_gihdot","mix_polydot_gihdot")
param_vec <- c()
hyperparams <- list(
'mix' = c(0.2, 0.4, 0.5, 0.6, 0.8),
'sigma' = c(1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1, 10),
'degree' = c(2, 3, 4, 5),
'beta' = c(0.1, 0.2, 0.25, 0.3, 0.4, 0.7, 0.9)
)
source("svm.R")
fit_models(kernels, Cs)
# Fits a KNN
source("knn.R")
fit_models(c(3, 5, 7, 9, 13, 15, 17, 21, 35, 51))
setwd('/home/benja/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/')
source("~/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/main.R")
library(kernlab)
library(imager)
library(xtable)
library(caret)
library(class)
options(scipen = 999)
# setwd('/home/benja/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/')
source("process_data.R")
# Read Data, only if it doesnt exist
if (!file.exists('data/train.RData')) read_data(train = T)
if (!file.exists('data/test.RData')) read_data(train = F)
# clear workspace
rm(list = ls())
load("data/train.RData")
load("data/test.RData")
# Fits an SVM
lambda <- 0.5; sigma_rbf <- 1; degree <- 2; beta <- 0.25; beta_gih <- 0.25
Cs = c(0.1, 1)
kernels = c("mix_polydot_gihdot")
param_vec <- c()
hyperparams <- list(
'mix' = c(0.2, 0.4),
'sigma' = c(1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1, 10),
'degree' = c(2, 3, 4, 5),
'beta' = c(0.1, 0.2, 0.25, 0.3, 0.4, 0.7, 0.9)
)
source("svm.R")
fit_models(kernels, Cs)
# Fits a KNN
source("knn.R")
fit_models(c(3, 5, 7, 9, 13, 15, 17, 21, 35, 51))
kernels = c("vanilladot", "rbfdot", "polydot", "gihdot", "logdot",
"laplacedot", "mix_rbfdot_polydot", "mix_rbfdot_logdot",
"mix_logdot_polydot", "mix_rbfdot_gihdot",
"mix_logdot_gihdot","mix_polydot_gihdot")
source("svm.R")
fit_models(kernels, Cs)
source("svm.R")
fit_models(kernels, Cs)
source("svm.R")
fit_models(kernels, Cs)
source("~/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/main.R")
source("~/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/main.R")
source("~/Documents/Universitat/Informatica/6.Sise/AA2/AA2-projecte/main.R")
